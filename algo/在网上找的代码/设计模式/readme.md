1. 创建型模式 (Creational Patterns)
这些模式关注于对象的创建机制，试图创建对象的过程独立于其他对象。

单例模式 (Singleton)：确保一个类只有一个实例，并提供一个全局访问点。
工厂方法模式 (Factory Method)：定义一个创建对象的接口，但让子类决定实例化哪一个类。
抽象工厂模式 (Abstract Factory)：提供一个接口，用于创建一系列相关或依赖对象而无需指定它们具体的类。
建造者模式 (Builder)：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
原型模式 (Prototype)：通过复制现有对象来创建新对象，而不是通过类实例化。
2. 结构型模式 (Structural Patterns)
这些模式处理对象和类的组合，封装了如何组装对象和类为较大的结构。

适配器模式 (Adapter)：允许不兼容接口的类一起工作。
桥接模式 (Bridge)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
组合模式 (Composite)：允许你将对象组合成树形结构来表示“部分-整体”的层次结构。
装饰器模式 (Decorator)：动态地给一个对象添加一些额外的职责。
外观模式 (Facade)：为子系统中的一组接口提供一个一致的界面。
享元模式 (Flyweight)：运用共享技术有效地支持大量细粒度的对象。
代理模式 (Proxy)：为另一个对象提供一个代理以控制对这个对象的访问。
3. 行为型模式 (Behavioral Patterns)
这些模式涉及算法和类之间的责任分配。

策略模式 (Strategy)：定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。
模板方法模式 (Template Method)：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。
命令模式 (Command)：将一个请求封装为一个对象，从而使你可用不同的请求来参数化客户端。
迭代器模式 (Iterator)：提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象内部细节。
观察者模式 (Observer)：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
中介者模式 (Mediator)：用一个中介对象来封装一系列的对象交互。
备忘录模式 (Memento)：在不破坏封装性的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态。
解释器模式 (Interpreter)：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
职责链模式 (Chain of Responsibility)：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。
每种设计模式都针对特定的问题场景，选择合适的设计模式可以提高代码质量和系统的可维护性。在实际应用中，可能需要结合多种设计模式来解决复杂的问题。